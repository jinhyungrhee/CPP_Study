# 제네릭 프로그래밍 : 템플릿

- 일반화(generalization)
  - 여러 상황에 적용할 수 있는 (공통의) 프로그램 하나를 만들 때 사용할 수 있는 방법
    - 이를 `템플릿 프로그래밍(template programming)` 또는 `제네릭 프로그래밍(generic programming)`이라고 함
  - 예시 : 같은 처리를 하는 코드를 여러 자료형에 적용해야 하는 경우
    - 2개의 정수 중에 작은 것을 찾는 처리와 2개의 부동 소수점 중에서 작은 것을 찾는 처리 등
    - 이러한 두 처리는 자료형은 다르지만 실질적인 코드는 같음
    - 이 경우, 제네릭 자료형(generic type)을 사용해서 제네릭 프로그래밍(=템플릿 프로그래밍)을 할 수 있음

## 함수 템플릿

- 함수는 0개 이상의 객체에 어떤 처리를 적용하고, 0개 이상의 객체를 만듦
- 함수 템플릿(function template)을 사용하면 프로그램을 작성할 때는 처리만 작성하고, 컴파일할 때 알아서 자료형이 세부적으로 지정되게 만들 수 있음
  - 즉 함수를 하나만 작성해도 여러 자료혀에 적용되는 함수를 여러 개 자동으로 만들 수 있음!
- 필요성
  - 템플릿 프로그래밍(제네릭 프로그래밍)을 사용하지 않는다면, 여러 개의 함수를 정의해야 함
- 함수 템플릿 문법
  - 템플릿 함수를 만들 때는 템플릿 자료형 위치에 플레이스홀더(placeholder)를 사용
    ```c++
    // 템플릿 함수를 만드는 문법
    template <typename T, typename U, ... , typename Z>
    T functionName(U first, ... Z last)
    {
      ...
    }
    ```
    - T, U, ... Z 등의 플레이스홀더가 실제 자료형으로 대체
    - 템플릿 헤더(함수의 이름, 매개변수 등)는 template 키워드와 <>괄호로 구성. <>괄호에는 함수 내부에서 사용할 자료형의 목록의 심볼을 지정
    - 템플릿 함수의 헤더는 일반적인 함수의 헤더와 같음. 다만 매개변수와 리턴 자료형으로 템플릿 헤더에서 선언한 심볼을 사용
    - 오래된 코드에서는 typename 대신 class를 사용하는 경우도 있지만, 현재 표준 c++ 라이브러리들은 내부적으로 typename 키워드를 사용

- 템플릿 인스턴스화(template instantiation)
  - 개별적인 자료형에 대한 함수 정의 생성이 컴파일 시점까지 이루어지지 않으며, 컴파일 되는 때에 컴파일러가 함수 호출에 필요한 만큼의 함수들을 만들어 냄
  - 클래스 인스턴스화와 전혀 다른 것이므로 구분해서 기억!

- 함수 템플릿 구문의 몇 가지 변형 형태
  - **자료형이 아닌 템플릿 매개변수**
    - 함수 템플릿으로 자료형이 아닌 값을 정의할 수도 있음
    - 값으로 정의해서 사용할 경우, 매개변수를 전달하는 것과 비슷한 역할
    - 자료형이 아닌 값을 정의하는 것이므로 자료형은 고정!
    - 예시) 요소의 종류나 배열의 크기와는 관계없이 배열의 요소를 출력하는 함수
      - 템플릿 매개변수 T와 N
      - 매개변수 T는 자료형, 매개변수 N은 자료형이 아닌 값을 나타냄
      - 자료형은 이미 int로 정의됨
  - **명시적 자료형 결정**
    - 특정 함수의 매개변수에 정수와 부동 소수점 자료형을 모두 넣으면 오류 발생
      ```c++
      cout << smaller(23, 67.2); // Error! Two types for the same T
      ```
    - T라는 자료형은하나의 템플릿 자료형이므로, 값이 반드시 같은 자료형이어야 함
    - 위 오류를 해결하려면 **명시적 자료형을 지정**!
      ```c++
      cout << smaller <double>(23, 67.2); // 23 will be changed to 23.0
      ```
  - **미리 정의된 연산**
    - int 자료형, double 자료형, char 자료형에는 < 연산자가 정의되어 있으므로 smaller 함수에 활용 가능
    - 이외에도 < 연산자가 오버로드 되어 있는 모든 자료형을 사용할 수 있음
    - 예시) 라이브러리 string 클래스는 < 연산자를 오버로드하고 있으므로, T를 string으로 대체해서 컴파일할 수 있음
      ```c++
      cout << smaller("Hello", "Bi"); // 결과 값으로 "Bi" 출력
      ```
    - C문자열과 Rectangle 자료형에는 이러한 연산자 오버로드가 되어있지 않으므로, 이러한 자료형을 smaller 함수에 활용하면 컴파일 오류 발생
      - 이러한 문제를 해결하려면 `템플릿 특수화` 사용
        - 템플릿 자료형이 아니라 특정 자료형으로 다른 함수를 정의해서 활용하는 것!
  - **템플릿의 오버로딩**
    - 함수 템플릿에도 오버로딩 개념 적용 가능
    - 이름이 같지만 시그니처가 다른 여러 개의 함수를 만들어낼 수 있음
    - 일반적으로 템플릿 자료형은 같지만 `매개변수의 수가 다른 함수`를 만들어낼 때 활용

## 클래스 템플릿

- 템플릿 함수와 마찬가지로 다른 자료형에 같은 처리를 하는 클래스를 만들어야 할 수도 있음
  - 이때 클래스 템플릿 사용!
- 템플릿은 문자열 클래스와 스트림 클래스와 같은 c++ 라이브러리에서도 사용
- 클래스 템플릿을 만들 때는 '데이터 멤버'와 '멤버 함수'를 모두 템플릿으로 만들어야 함
- 클래스 템플릿을 만들 때는 인터페이스와 구현 모두에 템플릿 매개변수가 있어야 함
  - **인터페이스**
    - 클래스의 인터페이스에서는 데이터 멤버와 멤버 함수에서 사용할 typename을 정의해야 함
    - 간단한 클래스 템플릿 문법
      ```c++
      template <typename T>
      class Name
      {
        private:
          T data;
        public:
          Name(); // 기본 생성자
          T get() const; // 접근자 멤버 함수
          void set(T data) // 설정자 멤버 함수
      };
      ```
  - **구현**
    - 템플릿 자료형을 사용하는 모든 멤버 함수 앞에 template<typename T>를 지정해야 함
      ```c++
      // 접근자 함수 구현
      template<typename T>
      T name<T>::get() const
      {
        return data
      }
      // 설정자 함수 구현
      template<typename T>
      void name<T>::set(T d)
      {
        data = d;
      }
      ```
- **비 템플릿 클래스 구현과 템플릿 클래스 구현에서 중요한 차이**
  - 템플릿 클래스로 구현 시, 컴파일러가 어플리케이션 파일을 컴파일할 때 템플릿 함수의 매개변수화가 이루어진 형태를 미리 인지하고 있어야 함!
  - 따라서 어플리케이션 파일에서 구현을 헤더 파일로서 포함해야 함
  - 즉, 구현 파일에 ifndef, define, endif 매크로를 추가해야 함

## 템플릿의 컴파일

- 여러 파일에 분산되어 함수 템플릿과 클래스 템플릿을 가지는 경우에도 여러 파일들을 컴파일하고 링크할 수 있음
- 2가지 방법 사용
  - **포함 방법(inclusion approach)**
    - 선언과 정의를 모두 헤더 파일에 넣고, 어플리케이션에서 헤더 파일을 읽어들이는 형태
      - 구분을 위해 선언을 .h파일로, 정의를 .cpp 파일로 만드는 것이 좋음
      - 어플리케이션 파일에서 구현 파일(.cpp)을 읽어 들이고, 구현 파일에서 인터페이스 파일(.h)을 읽어 들이는 형태로 사용
  - **분할 컴파일**
    - 템플릿 함수와 템플릿 클래스를 사용할 경우 기존의 분할 컴파일 방식을 사용할 수 없음
      - 컴파일러가 템플릿 함수와 템플릿 클래스의 내부 내용을 컴파일에 활용하므로, 구현 파일을 독립적으로 컴파일할 수 없는 문제 발생
      - C++ 표준에 `export` 키워드가 추가되면서 이러한 문제가 해결됨!
    - 기존의 분할 컴파일 방식을 사용하기 위해선, 템플릿 선언 또는 정의 앞에 `export` 키워드를 붙임
    - 주의 : 모든 템플릿 멤버 함수 앞에 붙여야 함!
      ```c++
      // fun.h
      export template<typename T>
      class Fun
      {
        ...
      };
      // fun.cpp
      export template<typename T>
      Fun <T>::Fun(T d)
      : data(d)
      {
      }
      ```
      - 구버전의 컴파일러에서는 오류 발생 -> '포함 방법' 사용
- 클래스 템플릿을 적용하기 스택 구현하기
  - 힙에 배열을 만들고 활용해서 스택을 구현

## friend와 typedef
- **friend**
  - 템플릿 클래스 선언 때 friend 함수를 포함할 수 있음
    - ① 템플릿 클래스는 비 템플릿 함수를 friend로 가질 수 있음
    - ② 템플릿 클래스는 템플릿 함수를 friend로 가질 수 있음
    - ③ 템플릿 클래스는 특수화된 템플릿 함수를 friend로 가질 수 있음
- **typedef(=별칭)**
  - typedef를 사용해서 템플릿 클래스의 별칭을 정의해서 사용
  - 별칭으로 일반적인 클래스처럼 사용 가능
  - 예시
    ```c++
    // stack 클래스에 자료형별 별칭 생성
    typedef stack<int> isStack;
    typedef stack<double> dStack;
    typedef stack<string, int> siStack;

    // 프로그램 내부에서 사용 시
    iStack s1;
    dStack s2;
    siStack s3;
    ```

## 템플릿 클래스의 상속

- 템플릿 클래스를 베이스 클래스로 템플릿 클래스 또는 비 템플릿 클래스를 파생할 수 있음
- 예시
  ```c++
  // First 템플릿 클래스
  template <typename T>
  class First
  {
    ...
  }

  // First를 베이스 클래스로 Second 클래스 파생
  class Second : public First<T>
  {
    ...
  }
  ```

## 많이 사용하는 템플릿 클래스

- 문자열 클래스(c++ 문자열)
  - string 클래스는 basic_string이라는 클래스를 특수화한 클래스
    ```c++
    template<typename charT>
    class basic_string
    {
      ...
    };
    ```
  - string 클래스를 기반으로 특수화한 2가지 클래스(in 라이브러리)
    ```c++
    typedef basic_string <char> string;
    typedef basic_string <wchar_t> wstring;
    ```

- 입출력 클래스
  - istream 클래스는 basic_istream 클래스를 char 자료형으로 특수화한 클래스
    ```c++
    typedef basic_istream <char> istream;
    typedef basic_istream <wchar_t> wistream;
    ```