# 표현식과 문장

## ▣ 표현식(Expression)

- 표현식은 특정 값을 가진 엔티티(개체)이며, 메모리의 상태를 변경할 수 있음
- 메모리 상태를 조작하는 행위를 `부가 효과(side effect)`라고 함
- C++ 표현식의 예
  |종류|이름|연산자|표현식|우선순위|결합 방향|
  |--|--|--|--|--|--|
  |기본 표현식|리터럴, 이름, 괄호 표현식|-|<리터럴>, <이름>, <표현식>|19|→|
  |단항 표현식|양수, 음수, .sizeof|+, -, sizeof|+<표현식>, -<표현식>, sizeof <표현식>|17|←|
  |곱셈 표현식|곱셈, 나눗셈, 나머지|*, /, %|<표현식>*<표현식> <표현식>/<표현식>, <표현식>%<표현식>|14|→|
  |덧셈 표현식|덧셈, 뺄셈|+, -|<표현식>+<표현식>, <표현식>-<표현식>|13|→|
  |할당 표현식|단순 할당, 복합 할당|=, <연산자>=|<변수>=<표현식>, <변수><연산자>=<표현식>|3|←|

### 기본 표현식(Primary expression)
- 기본 표현식은 연산자 없이 구성된 간단한 표현식
- 기본 표현식은 조합을 해서 더 복잡한 표현식을 구성하는 재료가 됨
- 리터럴
  - 리터럴은 값을 나타내지만 부가 작용이 없는 표현식
  - 리터럴의 예(short는 리터럴이 없음!)
    ```
    false       // Boolean literal
    12897234L   // long integer literal
    'A'         // character literal
    245.78F     // float literal
    "Hello"     // string literal
    114.7892    // double literal(default)
    234         // integer literal
    245.784321L // long double literal
    ```
  - 출력 예시
    ```
    cout << false << " " << 'A' << " " << "Hello" << endl;
    cout << 23412 << " " << 12897234L << endl;
    cout << 245.78F << " " << 114.782 << " " << 2.051L;
    return 0;

    //출력 결과
    0 A Hello            // Boolean, character, string
    23412 12897234       // integer, long integer(there is no short integer)
    245.78 114.782 2.051 // float, double, long double
    ```

### 괄호 표현식
- 이름
  - 이름으로 사용되는 식별자는 변수, 객체이름, 함수 이름 등에 사용
    ```
    x         // can be a name of a variable
    cout      // the name of an object
    std::cout // a name qualified with its namespace
    ```

- 괄호 표현식
  - 우선 순위가 낮은 표현식을 기본 표현식으로 변경하고 싶다면 괄호로 묶음
  - 이렇게 하면 연산자를 포함한 복잡한 표현식이 우선 계산
    ```
    (x+3) * 5  // x+3 먼저 실행
    12 / (x+2) // x+2 먼저 실행
    ```

### 단항 표현식

- 양수나 음수로 표현

### sizeof 표현식

- 표현식이나 자료형의 크기를 찾을 수 있음
- Byte크기로 사이즈 리턴

### 곱셈 표현식

- 산술 연산자
- 피연산자의 부호가 같으면 양수, 다르면 음수
- 곱셈
  - 두 값을 곱할 때는 * 기호 사용
  - 피연산자 2개의 자료형이 같지 않으면 자료형 변환이 일어남
- 나눗셈
  - 두 값을 나눌 때는 / 기호 사용
  - **피연산자 2개가 정수(int 등)라면 결과로 정수가 나옴**(=> *소수점이 나타나지 않음!*)
  - **피연산자가 하나라도 부동 소수점(double 등)이라면 결과는 부동 소수점으로 나옴**
- 나머지
  - 어떤 값을 다른 값으로 나눈 나머지를 구할 때는 나머지 연산자 % 기호를 사용

### 할당표현식

- 단순 할당
  - 단순 할당(simple assignment) 연산자는 = 기호를 사용
  - 왼쪽 피연산자는 변수여야 함!
  - 부가 작용(side effect)으로 이전 값이 사라지고 새로운 값이 저장됨
  - 부가 작용이 먼저 발생(=메모리에 변경이 발생)하고 최종 결과값이 생성됨

### 복합 할당

- 할당 연산자(=)와 오른쪽에 있는 연산자(+)를 결합해서 연산자(+=)를 사용
  ```
  x += 5      // x = x + 5
  y -= 3      // y = y - 3
  z *= 10     // z = z * 10
  t /= 8      // t = t / 8
  u %= 7      // u = u % 7
  ```

## ▣ 자료형 변환

- Static Cast(static_cast)
  - 암시적 캐스팅 / 명시적 캐스팅
  - 다운캐스팅 / 업캐스팅
    - 상속과 관련
  - 컴파일 단계에서 casting 처리

- Dynamic Cast(dynamic_cast)
  - 다형성 / 단형성
  - runtime 단계에서 casting 처리

- Const Cast(const_cast)
  - 포인터, 참조(상속) 관련

- Reinterpret Cast(reinterpret_cast)
  - 캐스팅 대상을 bit 단위로 재해석

### 자료형 확인

- \<typeinfo> 헤더파일 사용
- 자료형을 확인하는 코드 (객체에서 지원하는 함수 호출)
  - `typeid (expression).name()`

### 암묵적 자료형 변환

- 서로 다른 자료형을 연산하면 C++ 컴파일러는 연산 전에 암묵적 자료형 변환(implicit type conversion)을 수행
- 암묵적 자료형 승격(implicit type promotion)
  - 암묵적 자료형 승격은 산술 연산자의 피연산자에 자동으로 승격
  - 작은 크기의 자료형을 큰 크기의 자료형으로 바꿔주는 것
    |규칙|원래 자료형|승격된 자료형|
    |--|--|--|
    |1|bool|int|
    |2|char|int|
    |3|short|int|
    |3|unsigned short|unsigned int|
    |4|float|double|
- 암묵적 자료형 변환의 자료형 계층
  - `int` → `unsigned int` → `long` → `unsigned long` → `double` → `long double`
  - 반대로 내려가면 넘치기 때문에 개발자가 책임지고 명시적으로 컴파일러가 바꾸도록 선언해야 함!

### 명시적 자료형 변환(캐스팅)

- 피연산자의 자료형을 원하는 형태로 강제로 변환하는 것
- 명시적 자료형 변환(explicit type conversion) 또는 캐스팅(casting)이라고 부름
- C++에는 여러가지 캐스팅 방법이 있지만, `static_cast`를 사용한 캐스팅만 살펴봄
  - `static_cast <type> (expression)`
  - 예시
    ```
    double x = 23.56;
    int cpp = static_cast<int>(x); // double 타입을 int형으로 변환
    ```

## ▣ 표현식의 평가 순서(우선 순위)

- 둘 이상의 연산자가 조합된 복잡한 표현식이 있다면?
  - 우선순위 높은 것 먼저 처리!
- 예시 : 4개의 연산자가 조합된 표현식
  - `3 + 4 * 7 / 22 - 8`
- 이를 알려면 연산자의 우선 순위와 평가 순서(결합 방향)를 고려해야 함!

### 우선 순위
- 우선 순위가 다른 간단한 표현식이 조합되어서 복잡한 표현식을 이룬 경우, 다음과 같은 단계에 따라서 복잡한 표현식의 값을 처리함
  - (1) 우선 순위가 가장 높은 단순한 표현식을 평가하고 결과 값으로 표현식을 대체. 새로운 표현식이 만들어짐
  - (2) 모든 표현식이 평가될 때까지 1단계를 반복

## ▣ 오버플로우와 언더플로우

- 컴퓨터 시스템에서 숫자를 사용할 경우, 자료형에 따라 사용할 수 있는 메모리가 한정되어 있음
- 자료형의 최대값보다 크거나 최소값보다 작은 값을 저장하려고 하면 문제가 발생!
  - 이를 오버플로우와 언더플로우라고 부름
- C++은 이러한 오버플로우와 언더플로우에 대해서 간단한 경고를 출력해줄 때가 있지만, 오류 메시지를 생성하지는 않음
  - 개발자가 직접 관리해야 함!
- 오버플로우와 언더플로우가 발생하면 예상한 결과가 나오지 않음

### 부동 소수점의 오버플로우와 언더플로우

- 부동 소수점은 unsigned가 없음(무조건 부호가 있음!)
  ```c
  // double 자료형의 최대값과 최소값 검색
    double num1 = +numeric_limits<double>::max();
    double num2 = -numeric_limits<double>::max();
    // 최대값과 최소값 출력
    cout << "double의 최대값: " << num1 << endl; // 2147483647
    cout << "double의 최소값: " << num2 << endl; // -2147483648
    // 강제로 오버플로우와 언더플로우 발생
    num1 *= 1000.00;
    num2 *= 1000.00;
    // 오버플로우와 언더플로우된 값 출력
    cout << "오버플로우가 일어난 num1 * 1000의 값: " << num1 << endl; // -2147483648 (오버플로우가 발생하면 최소값으로 감 -> 순환)
    cout << "언더플로우가 일어난 num2 * 1000의 값: " << num2 << endl; // 2147483647 (언더플로우가 발생하면 최대값으로 감 -> 순환)

    return 0;

    // 출력 결과
    double의 최대값: 1.79769e+308
    double의 최소값: -1.79769e+308
    오버플로우가 일어난 num1 * 1000의 값: inf
    언더플로우가 일어난 num2 * 1000의 값: -inf
  ```

## ▣ 데이터 형식 조정

- 상황에 따라서 표준 형식(standard format)의 입출력 형식을 바꿔야 할 때가 있음
- 이를 위해 `조정자(manipulator)` 객체를 사용
- 조정자는 크게 `데이터 출력을 위한 조정자`와 `데이터 입력을 위한 조정자`로 구분됨!

### 출력 조정자

- 매개변수가 없는 출력 조정자
  |조정자 카테고리|불|문자|정수|부동 소수점|
  |--|--|--|--|--|
  |endl|v|v|v|v|
  |**noboolalpha**, boolalpha|v||||
  |**dec**, oct, hex|||v||
  |**noshowbase**, showbase|||v||
  |**(없음)**, fixed, scientific||||v|

  - endl 조정자
    - \n 조정자를 추가하여 줄바꿈을 하도록 설계

  - 불 리터럴 조정자(noboolalpha, boolalpha)
    - noboolalpha 조정자는 불 값을 정수(0 또는 1)로 출력
    - boolalpha 조정자는 불 값을 리터럴(false 또는 true)로 출력
    - 입력 조정자로도 사용

  - 숫자의 진법을 변경하는 조정자(dec, oct, hex)
    - 컴퓨터는 내부에서 2진법으로 모든 데이터를 저장하고 조작
    - 출력할 때는 일반적으로 10진법(dec), 8진법(oct), 16진법(hex) 중 하나로 출력
    - 보통 10진수(dec)로 출력하지만, 다른 진법으로 보는 것이 더 편리한 상황에는 다른 진법으로 출력해서 보는 것이 좋음
    - 입력 조정자로도 사용

  - 진법의 접두사를 붙이는 조정자(noshowbase, showbase)
    - 숫자를 다른 진법으로 출력할 때, 어떤 진법으로 출력하고 있는지 나타내는 접두사를 지정하는 조정자
    - 10진수는 아무 것도 붙지 않고, 8진수는 0, 16진수는 0x가 접두사로 붙어서 각각의 진법을 나타냄

  - 고정 소수점 출력 조정자와 과학 표기법 출력 조정자(fixed, scientific)
    - **고정 소수점 형식(fixed)**
      - `| 부호 | 정수부분 | • | 소수점 아래 부분 |`
    - **과학 표기법 형식(scientific)**
      - `| 부호 | 정수 부분이 한 자리로 고정 | e 또는 E | 지수 부호 | 지수 |`
      - 정규화 과정을 통해서 정수부분이 한 자리로 고정되도록 함
      - 왼쪽으로 이동했는지, 오른쪽으로 이동했는지는 지수 부호 값을 통해 표현
    
  - 소수점 아래 부분을 출력하는 조정자(showpoint)
    - 소수점 아래 부분이 0인 경우에도 출력

  - 부호를 출력하는 조정자(showpos)
    - 양수인 경우에도 + 출력

- 매개변수가 있는 조정자

  - 정해진 크기의 영역에서 배치를 조정하는 조정자(left, right, internal)
    - left : 왼쪽 정렬
    - right : 오른쪽 정렬
    - internal : 부호는 왼쪽 정렬, 값은 오른쪽 정렬

  - 매개변수가 하나인 조정자
    |조정자|불|문자|정수|부동 소수점|
    |--|--|--|--|--|
    |setprecision(n)||||v|
    |setw(n)|v|v|v|v|
    |setfill(ch)|v|v|v|v|

    - setprecision(n) : 괄호 안의 정수(n)로 소수점 뒤의 몇 자리까지 출력할지 지정(부동 소수점 정밀도)
    - setw(n) : 괄호 안의 정수(n)는 전체 필드 크기를 의미. 정수부분 + 소수점 + 소수점 아래 부분을 모두 합친 길이(자리수)
    - setfill(ch) : 필드의 크기가 실제 출력되는 내용보다 클 때 발생하는 패딩을 어떤 문자로 채울지 지정

## ▣ 문장

- C++ 프로그램은 문장이 모여서 구성
- 문장은 프로그래밍에서 실행할 수 있는 최소 단위의 코드
- 어떤 문장은 그 문장을 종료하기 위해서 자연 언어의 마침표처럼 세미콜론(;)이 필요

### 선언문

- 선언문
  - 선언(assignment)과 정의(definition)
  - 선언 : 자료형과 이름을 지정해서 엔티티를 생성
  - 정의 : 엔티티를 위해서 메모리를 할당하는 것

- 변수 선언
  - 변수를 선언하는 문장을 변수 선언문(variable declaration)이라고 부름
  - 변수 선언문은 extern이라는 별도의 한정을 붙이지 않는 이상, 선언과 정의를 동시에 함
  - 변수 선언문은 문장의 마침표로서 세미콜론을 입력해야 함
  - 예시
    - 단일 선언
      ```c
      short test;
      int sum;
      double average;
      ```
    - 복수 선언
      ```c
      int first, second, third;
      double average, mean;
      char ch;
      ```
    - 초기화
      ```c
      int first = 0;
      double average = 0.0, mean = 0.0; // 복수 선언 + 초기화
      char ch = 'a';
      ```
    - 상수 선언
      ```c
      // 상수는 선언과 동시에 초기화가 이루어져야 함!!
      const int FOOT_TO_INCH = 12;
      const double TAX_RATE = 8.5;
      const double PI = 3.1415926336;
      ```

- 표현식 구문(expression statement)
  - 표현식 뒤에 마침표로 세미콜론을 붙인 문장
  - 예시
    ```c
    num = 24;         // 표현식 구문
    num *= 10;        // 표현식 구문
    num = data + 6;   // 표현식 구문
    num1 + num2;      // 부가 효과(side effect)가 없음. 사용할 필요가 없는 표현식 구문
    num1 * 6;         // 부가 효과(side effect)가 없음. 사용할 필요가 없는 표현식 구문
    num;              // 부가 효과(side effect)가 없음. 사용할 필요가 없는 표현식 구문
    6;                // 부가 효과(side effect)가 없음. 사용할 필요가 없는 표현식 구문
    cout << "Hello!"; // 출력
    cin >> data;      // 입력
    ```

### 입출력 객체와 연산자

- 스트림 객체는 프로그램을 물리적인 입력 장치(키보드 등)나 물리적인 출력 장치(모니터 등)와 연결하는 관
- 키보드와 연결된 스트림이 cin, 모니터와 연결된 스트림이 cout
- `>>` 기호(추출 연산자, extraction operator)는 cin 객체 내부에서 정의된 연산자
- `<<` 기호(삽입 연산자, insertion operator)는 cout 객체 내부에서 정의된 연산자

### 복합 구문과 리턴 구문, 널 구문

- 복합 구문
  ```c
  {
    int num = 0;
    cout << num << endl;
  }
  ```

- 리턴 구문
  ```c
  int main()
  {
    ...
    return 0;
  }
  ```

- 표현식 구문과 널 구문을 사용한 예
  ```c
  num = 24; ; // 널 구문(null statement)은 아무 것도 하지 않는 문장
  
  for(;;)
  ```