# 추상 클래스와 다중 상속

- 구체 클래스(concrete class)는 인스턴스화해서 해당 클래스 자료형의 객체를 만들 수 있는 클래스를 의미
  - 실체가 있는 클래스
- ⭐is-a 관계를 갖지는 않는데 같은 종류의 함수를 만들어야 하는 경우⭐
  - 상위 카테고리를 만들어야 하는 상황과 유사
- 예시 : Rectangle 클래스와 Square 클래스
  - 두 클래스에는 getArea와 getPerimeter 멤버 함수를 만들 수 있음
  - 만약 파생 클래스를 설계하는 개발자가 **반드시 2개의 함수를 구현하도록 강제**하려면 어떻게 해야 할까?

## 추상 클래스

- 객체 지향 프로그래밍에서는 `추상 클래스(abstract class)`를 사용해 파생 클래스를 설계하는 개발자에게 **만들어야 하는 함수를 강제**함
- 추상 클래스는 **적어도 하나 이상의 순수 가상 함수를 포함하는 클래스**를 의미함!

- **순수 가상함수 선언**
  - 추상 클래스는 하나 이상의 순수 가상 함수를 가지고 있어야 함
  - `순수 가상 함수(pure virtual function)`는 선언 시 0을 할당하고, 가상 함수의 정의는 하지 않음(코드X)
  - 예시 : Shape 클래스의 두 가상 함수 선언
    ```c++
    virtual double getArea(0) = 0;
    virtual double getPerimeter(0) = 0;
    ```

- **순수 가상 함수 정의**
  - 추상 클래스는 순수 가상 함수를 정의하지 않음
  - 추상 클래스를 상속하는 다른 클래스에서 순수 가상 함수를 정의함
  - 또는 정의하지 않고 다음 상속 단계로 넘길 수도 있음

- 인스턴스화 불가
  - 추상 클래스에는 순수 가상 함수에 대한 정의가 없으므로 클래스를 인스턴스화할 수 없음
  - 클래스를 인스턴스화하려면, 모든 멤버 함수에 대한 정의가 있어야 함
  - 따라서 추상 클래스를 상속받아 모든 멤버 함수를 정의한 뒤 인스턴스화해야 함!

### 인터페이스

- 추상 클래스는 내부적으로 가상 함수와 순수 가상 함수를 모두 가질 수 있음
- 경우에 따라서 **모든 멤버 함수를 순수 가상 함수로 갖는 경우**도 있음
  - 이러한 클래스를 `인터페이스(interface)`라고 함
- 인터페이스는 모든 멤버 함수가 순수 가상 함수이므로, 구현 파일에 입력할 내용 자체가 없음
  - 따라서 구현 파일을 만들지 않음!
- 예시 : Shape 클래스
  - 도형을 나타내는 Shape 추상 클래스를 만들고, 이 클래스를 기반으로 Square(정사각형), Rectangle(직사각형), Triangle(삼각형), Circle(원), Ellipse(타원)을 타나내는 5개의 구체 클래스를 생성

## 다중 상속

- C++은 다중 상속(multiple inheritance) 지원
  - 자바는 지원하지 않음
- 둘 이상의 클래스를 베이스 클래스로 파생 클래스를 만드는 상속
- ❗다중 상속시 **데이터 멤버의 중복 문제**가 발생할 수 있음❗
  - ① `가상 베이스 상속(virtual base inheritance)` 사용하여 해결
    - 상속 때 virtual 키워드를 붙여서 '가상의 베이스'를 만들어 상속 받음!
    - 코드
      ```c++
      class Person {...};
      class Student: virtual public Person {...};   // 가상 베이스 상속 : Person에서 정의한 데이터 멤버를 Student에서 직접적으로 사용 불가(볼 수 없음)
      class Professor: virtual public Person {...}; // 가상 베이스 상속 : Person에서 정의한 데이터 멤버를 Professor에서 직접적으로 사용 불가(볼 수 없음)
      class TA: public Student, public Professor {...};
      ```
      - 가상 베이스 상속을 사용하면, 파생 클래스에 베이스 클래스의 멤버가 직접적으로 들어가지 않음
      - 따라서 TA 클래스가 Student 클래스와 Professor 클래스의 데이터 멤버 name을 상속받는 충돌이 일어나지 않음
    - 가상 베이스를 활용할 경우, **위임을 피해야 함!**
      - TA 클래스에서 print() 함수를 정의하고, 이 함수에서 베이스 클래스의 print() 함수를 호출하면 데이터 멤버 name이 3번 출력됨
      - 이러한 문제를 피하려면 공통 데이터 멤버(private)를 'protected'로 만들어서 모든 파생 클래스에서 접근할 수 있게 하고, 위임이 있는 멤버 함수를 사용하지 않아야 함!
      - 즉, 데이터 멤버를 직접 사용하게 코드를 구성해야 함!
  - ② `믹스인 클래스(mixin class)` 사용하여 해결
    - 믹스인 클래스 : 순수 가상 함수를 가져서 인스턴스화할 수 없지만, **다른 클래스에 데이터 멤버를 추가**해주는 클래스("섞여서 안으로 들어감")
      - 원래의 베이스 클래스에서 데이터 중복이 발생하는 것들을 뽑아내서 '믹스인 클래스'에서 따로 관리함
        - StdType 믹스인 클래스 : gpa 정보만 관리
        - PrfType 믹스인 클래스 : salary 정보만 관리