# 배열

- 배열은 자료형(type), 용적(capacity), 크기(size)라는 3가지 속성이 있음
- 자료형
  - 요소(element)의 자료형을 의미
  - ex) int 배열, double 배열, char 배열, Circle 배열 등
  - 배열 내부의 모든 요소는 같은 자료형을 가짐
- 용적
  - 보유할 수 있는 요소의 최대 수
  - 배열이 선언된 이후에는 변경할 수 없는 상수(또는 리터럴)값임!
    - 용적으로 리터럴 값 사용
      ```c++
      int scores[8];
      ```
    - 용적으로 상수 값 사용
      ```c++
      const int CAPACITY = 8;
      int scores[CAPACITY];
      ```
  - 일반적으로 용적을 나타내는 상수는 '대문자'를 사용
- 크기
  - 어떤 시점에 존재하는 요소의 수
  - 유효한 데이터의 수
  - 크기는 시간에 따라서 변함
- 배열의 생성
  - 사용 전에 미리 선언해야 하며, 이렇게 하면 컴파일러가 메모리의 특정 위치에 배열을 할당함
  - 처음 배열 선언 시, 배열의 요소를 초기화할 수 있음
  - 배열 선언(array declaration)
    - 배열에 이름, 요소의 자료형, 배열의 용적을 지정하여 메모리에 영역을 할당하는 작업
  - 초기화
    - 배열 각각의 요소는 하나의 단독적인 변수와 같음
    - 배열 선언 시, 컴파일러는 배열의 자료형에 맞게 메모리 위치를 할당하며 이 때 초기화는 일반적인 변수처럼 구현
      - 배열이 `전역 영역`에서 선언된 경우, 모든 요소는 자료형의 기본값으로 할당
        - 불 자료형은 false, char 자료형은 null문자, int 자료형은 0, 부동 소수점 자료형은 0.0, 객체 자료형은 기본 생성자로 생성된 객체가 기본값
      - 배열이 `함수 내부(main함수 등)`에서 선언된 경우, 쓰레기값으로 초기화됨
    - 초기화 종류 (명시적, 암묵적, 나머지 요소의 기본 초기화)
      - **명시적 초기화**
        - 배열의 초기값을 명시적으로 지정할 수 있으며 배열의 초기값은 중괄호 내부에 값들을 쉼표로 구분하여 지정
          ```c++
          ```
        - 객체 자료형의 배열도 초기화할 수 있음
          ```c++
          const int CAPACITY = 4;
          Circle circles[CAPACITY] = {Circle(4.0), Circle(5.0), Circle(6.0), Circle(7.0)};
          ```
      - **암묵적 초기화**
        - 용적을 지정하지 않고 배열을 선언할 수 있음
        - 컴파일러가 알아서 용적을 설정
          ```c++
          int scores[] = {87, 92, 100, 65, 70, 10, 96, 77};
          ```
      - **나머지 요소의 기본 초기화**
        - 초기화하는 값이 배열의 용적보다 크면 컴파일 오류 발생
        - 초기화하는 값이 배열의 용적보다 작은 것은 상관 없음
          - 이 경우, 배열이 선언되는 위치와 상관없이 배열의 나머지 값은 기본값으로 채워짐
            ```c++
            const int CAPACITY = 10;
            int scores[CAPACITY] = {87, 92, 100};
            ```
          - 예시) 100개의 요소를 갖는 배열의 모든 요소를 0.0으로 명시적으로 초기화
            ```c++
            const int CAPACITY = 100;
            int anArray[CAPACITY] = {0.0};
            ``
- 배열 요소에 접근
  - 첨자(subscript)라는 후위 표현식을 사용해서 값을 읽음
  - 첨자 표현식은 첨자 연산자인 [...]를 사용하는 표현식
  - 피연산자를 하나 갖는데, 피연산자는 바로 배열의 이름임
  - **out of range 오류**
    - 배열의 용적보다 큰 인덱스의 요소에 접근할 경우 발생
    - 만약 범위를 넘어서는 배열의 요소를 추출해서 값을 지정하면, 데이터와 프로그램에 심각한 문제가 발생할 수 있음
- 병렬 배열
  - 하나의 행(row)으로 여러 종류의 값을 표현해야 하는 데이터가 있을 수 있음
  - 마치 2차원 배열처럼 묶어서 활용
- 다차원 배열(multidimensional array)
  - 일반적으로 2차원 배열을 사용
  - **2차원 배열**
    - 행(row)과 열(column)이라는 2개의 인덱스를 사용해 요소를 저장하는 구조화된 자료형
    - 첫 번째 인덱스는 행을 나타내며, 두 번째 인덱스는 열을 나타냄
    - **2차원 배열을 함수의 매개변수로 전달할 때, 두 번째 차원의 크기를 정의해줘야 함!**
      - 첫 번째 차원의 크기는 별도의 매개변수로 따로 전달하여 함수 내부에서 활용!
        ```c++
        void function(int array[][3], int rowSize);
        ```
    - 2차원 배열에서만 사용할 수 있는 **특별한 연산**
      - `배열 접기(fold)`
        - 2차원 배열을 가로 축(행) 또는 세로 축(열)으로 접는 연산
        - 예시1) 중첩 반복문을 사용해서 '행'으로 접는 예시
          ```c++
          for (int i = 0; i < rowSize; i++)
          {
            for (int j = 0; j < colSize; j++)
            {
              foldedArray[rowSize - 1 - i][j] = originalArray[i][j]; // 0번 행을 2번 행에, 2번 행을 0번 행에 넣는 것
            }
          }
          ```
        - 예시2) 중첩 반복문을 사용해서 '열'로 접는 예시
          ```c++
          for (int j = 0; j < colSize; j++) 
          {
            for (int i = 0; i < rowSize; i++)
            {
              foldedArray[i][colSize - 1 - j] = originalArray[i][j];
            }
          }
          ```
      - `배열 전치(transpose)`
        - 2차원 배열의 행과 열을 바꾸는 것
          - 행 방향으로 변환(읽어냄)
          - 열 방향으로 변환(읽어냄)
          - 지그재그 방향으로 변환(읽어냄)
          - 예시) 중첩 반복문을 사용하여 배열을 전치하는 예시
            ```c++
            for (int i = 0; i < orgRowSize; i++)
            {
              for (int j = 0; j < orgColSize; j++)
              {
                transposedArray[j][i] = originalArray[i][j]; // 지그재그 방향? 확인 필요!
              }
            }
            ```
      - `선형 변환(linearization)`
        - 2차원 배열의 내용을 1차원 배열로 변환하는 것
  - 3차원 배열
    - 3차원 배열은 for반복문이 많이 중첩되므로 거의 사용하지 않음
    - 차원의 순서는 '면', '행', '열'임
      ```c++
      int employees[3][4][12]; // 3개의 면, 4개의 행, 12개의 열
      ```
- 빈도 배열(frequency array)
  - 어떤 상황이 발생하는 횟수를 셀 때 활용
  - 빈도 배열을 이용하면 히스토그램을 만들 수 있음