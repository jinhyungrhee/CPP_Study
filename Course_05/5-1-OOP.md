# 객체 지향 프로그래밍

- 객체 지향 프로그래밍으 위한 파일 구분
  - `클래스 정의 : (circle.cpp)` → `인터페이스 파일 : (circle.h)`
  - `멤버 함수 정의 : (circle.cpp)` → `구현 파일 : (circle.cpp)`
  - `어플리케이션 : (circle.cpp)` → `어플리케이션 파일 : (app.cpp)`

- 인터페이스 파일
  - 클래스 정의(데이터 멤버 선언과 멤버 함수 선언)가 포함된 파일
  - 클래스의 형태를 다른 파일에 알려주는 역할
  - 일반적으로 `h 확장자`를 붙임
    - h는 헤더파일을 의미!
- 구현 파일
  - 멤버 함수 정의가 포함된 파일
  - 인터페이스 파일에는 모든 멤버 함수의 '선언'을 입력
  - 일반적으로 `cpp 확장자`를 붙임
- 어플리케이션 파일
  - 객체를 인스턴스화하고 객체를 활용하는 main 함수의 코드가 포함된 파일
  - 반드시 `cpp 확장자`를 사용해야 함
    - app.cpp라는 이름을 사용하는 경우 多

- 분할 컴파일
  - 파일을 3개 만들었다면, 모든 파일을 컴파일해서 (object파일을 만든 후) 실행파일을 만들어야 함
  - 이렇게 분할된 파일을 컴파일하는 것을 '분할 컴파일(seperate compilation)'이라고 함
  - 과정
    - 인터페이스 파일에는 클래스 정의만 작성하며 이 파일은 이후에 구현 파일과 어플리케이션 파일에서 읽어들어야 함
    - 구현 파일(멤버 함수 정의)에서 include 지시문으로 인터페이스 파일을 읽어 들여 컴파일 함  
      `c++ -c circle.cpp`
    - 어플리케이션 파일에는 main 함수를 작성하며, 파일 가장 앞부분에서 인터페이스 파일을 읽어들임  
      `c++ -c app.cpp`
    - 만들어진 2개의 객체 파일(object파일)을 합쳐서 실행 파일을 생성  
      `c++ -o application circle.o app.o`
    - 최종적으로 만들어진 실행파일 실행  
      `c++ application` 

- 전처리 지시문(preprocessor directive)
  - 같은 헤더 파일을 2회 이상 읽어 들이면 컴파일할 때 오류 발생!
  - 이를 방지하기 위해 define, ifndef, endif의 3가지 전처리 지시문 사용
    ```c++
    #ifndef CIRCLE_H // circle.h가 정의되어 있지 않으면,
    #define CIRCLE_H // 새롭게 정의함!
      // circle.h 파일의 내용
    #endif
    ```
  - ifndef 지시문은 if 조건문과 비슷
    - 만약 플래그가 정의되어 있지 않으면, ifndef의 본문을 읽어 들여 CIRCLE_H의 코드를 포함함
    - 플래그가 이미 정의되어 있다면, 이후의 내요을 무시하고 곧바로 endif 지시문 위치로 이동함
    - 예시 : circle.cpp 또는 app.cpp 파일
      ```c++
      #ifndef CIRCLE_H
      #define CIRCLE_H
        // circle.h 파일의 내용  => 읽어들임
      #endif
        ...
      #ifndef CIRCLE_H
      #define CIRCLE_H
        // circle.h 파일의 내용  => 무시됨
      #endif
      ```

- 캡슐화
  - 별도로 컴파일하는 이유?
    - 객체 지향 프로그래밍의 캡슐화 목표 달성!
    - 캡슐화를 통해 '클래스 설계'와 '클래스 사용'을 구분함
  - **클래스 설계**
    - 설계자가 인터페이스 파일과 구현 파일을 만들고 인터페이스 파일만 공개함
    - 구현 파일의 경우 컴파일된 결과물만 공개하고, 소스코드는 비공개로 유지
    - 설계자는 필요할 때마다 구현 파일을 변경하고 컴파일한 후에 다시 배포 가능
  - **클래스 사용**
    - 사용자는 인터페이스 파일의 복사본과 컴파일된 구현 파일을 받음
    - 이를 어플리케이션 파일에서 읽어들이고 컴파일함
    - 최종적으로 모든 파일을 연결해서 실행 파일을 생성
  - 효과
    - 설계자는 사용자의 변경으로부터 인터페이스 파일과 구현 파일을 보호할 수 있음
    - 설계자가 컴파일된 구현 파일을 사용자에게 배포하므로 구현 파일도 사용자가 변경할 수 없음
    - 컴파일은 단방향으로 이루어지므로 컴파일된 구현 파일로는 원본 파일을 구할 수 없음
    - 따라서 전체적인 설계는 상자 내부에 캡슐화되어 감추어지며, 사용자가 마음대로 변경할 수 없음!
  - 공용 인터페이스
    - 설계자는 일반적으로 공용 인터페이스(public interface)라는 것을 만들어서 제공
    - 사용자가 어플리케이션에서 클래스를 사용하는 방법을 이해할 수 있게 정리한 멤버함수의 선언과 설명임
    - 즉, 함수 정의가 적혀 있는 텍스트 파일로, 사용자에게 클래스의 사용 방법을 설명하는 역할