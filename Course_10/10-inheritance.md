# 클래스 간의 관계

- 객체 지향 프로그래밍에서 클래스는 단독으로 사용하지 않음
- 프로그램에서는 여러 개의 클래스를 사용하며 이 클래스들은 서로 연관됨
- 클래스 관계
  - 상속 : is-a
  - 연관 : is related to(=association)
    - 소유(=집합, aggregation)
    - 구성
  - 종속 : uses-a
  
## ①상속

- 객체 지향 프로그래밍에서 상속(Inheritance)은 범용적인 개념에서 더 구체적인 개념을 만들 때 사용
  - 일상 생활에서의 예시 : 동물(Animal)은 말(Horse)보다 더 범용적인 개념을 가짐
  - 프로그램에서의 구현 : Animal 클래스를 만들고, 이를 기반으로 상속해서 Horse 클래스를 만듦
- 이러한 관계를 `is-a` 관계라고 부름
  - 말은 동물이지만(Horses are animals), 모든 동물은 말이 아님(not all animals are horses)
- 클래스들의 관계를 설명할 때 `UML` 사용
  - Unified Modeling Langauge : 클래스와 객체들의 관계를 시각적으로 나타내는 언어
  - UML 다이어그램을 보면 객체들의 상속 관계를 알 수 있음
- `범용적인 클래스`를 '베이스 클래스(base class)' 또는 '슈퍼 클래스(superclass)'라고 부름
- `구체적인 클래스`를 '파생 클래스(derived class)' 또는 '서브 클래스(subclass)'라고 부름
- 구체적인 클래스는 범용적인 클래스보다 많은 특징을 가짐
  - '말'은 일단 동물이라는 특징을 모두 가진 상태에서 추가적인 특징을 더 가짐
  - 따라서 파생클래스는 베이스 클래스를 `확장(Extend)`한 것이라고 표현!
  - 파생클래스는 베이스 클래스의 모든 데이터 멤버와 멤버 함수를 가진 상태에서(**다만 생성자, 소멸자, 할당 연산자는 제외**) 추가적인 데이터 멤버와 멤버 함수를 가짐
    - 파생클래스는 새로운 데이터 멤버와 멤버 함수를 가지기 때문
  - 베이스 클래스를 기반으로 파생 클래스를 만들 때는 `public`, `protected`, `private` 중 하나를 선택
  - 상속은 클래스를 선언할 때 클래스 이름 뒤에 콜론(:)을 입력하고 접근 제한자(public, protected, private)와 베이스 클래스의 이름을 붙여서 만듦
    ```c++
    // D가 파생 클래스, B가 베이스 클래스
    
    // 1. public 상속
    class D : public B
    {
      ...
    };

    // 2. protected 상속
    class D : protected B
    {
      ...
    };

    // 3. private 상속
    class D : private B
    {
      ...
    };
    ```
  - 상속의 종류를 따로 지정하지 않으면 private 상속이 이루어짐
    - 다만, private 상속은 잘 사용하지 않으므로 명시적으로 상속을 할 때 접근 제한자의 종류를 지정하는 것이 일반적!
  - **가장 많이 사용되는 상속**의 종류는 **public 상속**

### public 상속

- 일반적으로 사용하는 상속
- 파생 클래스가 베이스 클래스와 is-a 관계를 가질 때 사용
  - 파생 클래스의 객체가 베이스 클래스의 객체일 때
- 예시) Person과 Student 클래스 
  - 학생도 사람이므로 Student 클래스는 Person 클래스의 상속을 받도록 구성
  - Person 클래스는 identity(주민등록번호 등 식별자)만 데이터 멤버로 가지고, Student 클래스는 identity와 gpa(학점)를 데이터 멤버로 가짐
  - Student 클래스의 데이터 멤버 identity는 Person 클래스에서 상속받으므로, identity를 따로 선언하지 않아도 사용 가능
    ```
    // UML

      Person
    ---------------------------
    -identity:long
    ---------------------------
    +setId(long identity):void
    +getId():int
        △
        ㅣ
        ㅣ
      Student
    ---------------------------
    -gpa:double
    ---------------------------
    +setGPA(double gpa):void
    +getGPA():double
    
    // 자료형은 이름 뒤에 콜론을 붙임
    // 마이너스 기호는 private 멤버를 의미
    // 플러스 기호는 public 멤버를 의미
    ```
- public과 private의 상관 관계
  - 파생 클래스에서는 상속된 private 데이터 멤버에 직접 접근할 수 없음
  - 베이스 클래스의 멤버 함수를 통해서만 접근 가능
    - 베이스 클래스의 public 멤버 함수가 파생 클래스의 public 멤버 함수로 상속됨
  - Student 클래스에서 Person 클래스의 set함수를 호출해서 identity 속성을 설정하게 함
    - 이처럼 베이스 클래스에 어떤 작업을 하게 만드는 것을 `위임(delegation)`이라고 함
      ```c++
      // Person 객체 사용
      void Person::set(long id)
      {
        identity = id;
      }
      void Person::print()
      {
        cout << name;
      }

      // Student 객체 사용
      void Student::set(long id, double gp)
      {
        Person::set(id); // 위임(id는 person클래스의 멤버함수를 통해 설정)
        gpa = gp;
      }
      void Student::print()
      {
        Person::print(); // 위임(id는 person클래스의 멤버함수를 통해 출력)
        cout << gpa;
      }
      ```

### 오버로드와 오버라이드

- 오버로드
  - 같은 이름을 가지지만 함수의 시그니처(매개변수의 개수, 자료형, 순서)가 다른 경우
  - 멤버 함수 오버로드
    - 베이스 클래스와 파생 클래스에 같은 이름의 함수가 있을 때, 함수 시그니처가 다르면 둘 다 사용 가능!
      ```c++
      // Person class
      void set(long identity);

      // Student class
      void set(double gpa);
      ```
- 오버라이드
  - 베이스 클래스와 파생 클래스 모두 이름도 같고 시그니처도 같은 함수를 만든 경우
  - 함수 내부 동작을 바꾸는 '재정의'
    ```c++
    // Person class
    long get();

    // Student class
    double get();
    ```

### 클래스 스코프

- public 상속을 할 때도 스코프가 생김
  - 베이스 클래스도 자신의 스코프를 갖고 파생 클래스도 자신의 스코프를 가짐
- 컴파일러는 다음 규칙에 따라 적절한 스코프의 멤버 함수를 호출함
  - ① 컴파일러는 멤버 함수를 호출한 객체의 클래스에서 이름과 매개변수가 같은 함수를 찾음
  - ② 만약 찾지 못하면, 베이스 클래스에서 이름과 매개변수가 같은 함수를 찾음
  - ③ 만약 찾지 못하면, 계속해서 베이스 클래스의 베이스 클래스를 타고 올라가면서 찾음
  - ④ 상속 계층 전체에서 찾지 못하면, 컴파일 오류를 일으킴

### 상속되지 않는 멤버

- `기본 생성자`, `매개변수가 있는 생성자`, `복사 생성자`, `소멸자`, `할당 연산자`는 파생 클래스로 상속되지 않음
- 파생 클래스는 일반적으로 베이스 클래스보다 많은 데이터 멤버를 가지므로, 생성자와 소멸자가 상속되지 않음
- 파생 클래스에서는 더 많은 데이터 멤버를 초기화해야 하고, 그에 따라서 더 많은 데이터 멤버를 소멸시켜야 함
- 그러나 파생 클래스의 멤버 함수에서 베이스 클래스의 private 데이터 멤버에는 접근할 수 없으므로, 생성자에서 상속된 private 데이터 멤버에 접근이 되지 않아 초기화가 불가능함
- 이와 마찬가지로 소멸자도 상속된 private 데이터 멤버를 소멸시킬 수 없음
- 상속 시의 생성자와 소멸자
  - 파생 클래스의 생성자
    - ① 베이스 클래스의 생성자 호출
    - ② 파생 클래스의 데이터 멤버 초기화
  - 파생 클래스의 소멸자
    - ① 파생 클래스의 데이터 멤버 제거
    - ② 베이스 클래스의 소멸자 호출
  - 파생 클래스에서 베이스 클래스를 호출함
    ```c++
    // 베이스 클래스
    Person::Person()
    :identity(0)
    {
    }
    Person::Person(long id)
    :identity(id)
    {
    }
    Person::Person(const Person& obj)
    :identity(obj.identity)
    {
    }
    Person::~Person()
    {
    }

    // 파생 클래스
    Student::Student()
    :Person(0), gpa(0.0) // 베이스 클래스 생성자를 먼저 호출, 그 다음 초기화
    {
    }
    Student::Student(long id, double gp)
    :Person(id), gpa(gp) // 베이스 클래스 생성자를 먼저 호출, 그 다음 초기화
    {
    }
    Student::Student(const Student& st)
    :Person(st), gpa(st.gpa) // 베이스 클래스 생성자를 먼저 호출, 그 다음 초기화
    {
    }
    Student::~Student()
    {
    }
    ```

### 상속의 접근과 막기

- protected 멤버
  - 베이스 클래스에서는 private 멤버처럼 작동하고, 파생 클래스에서는 public 멤버처럼 작동
  - 예시) 파생 클래스에서 set 함수를 만든 뒤 베이스 클래스의 멤버 함수를 호출(위임)하는 예
    ```c++
    void Derived::set(int y)
    {
      Base::set(y); // 베이스 클래스의 멤버 함수 호출(위임)
    }
    ```
    - 데이터 멤버를 protected로 정의했다면, 파생 클래스에서도 데이터 멤버를 볼 수 있음
    - 따라서 직접적으로 데이터 멤버의 내용을 변경할 수 있음

- private 데이터 멤버 사용
  - private 데이터 멤버를 사용하면 `캡슐화` 유지 가능
    - 캡슐화 : 클래스의 데이터를 밖에 드러나지 않게 만드는 것
  - private 데이터 멤버를 사용하면 클래스 외부의 모든 곳에서 데이터 멤버에 접근할 수 없음
  - 따라서 파생 클래스에서 데이터 멤버에 접근하려면 추가적인 데이터 코드 필요(위임)
  - 장점 : 캡슐화
  - 단점 : 추가적인 코드 필요

- protected 데이터 멤버 사용
  - 캡슐화를 깨뜨리는 문제 발생
  - 다만 private 데이터 멤버를 사용할 경우 클래스 설계가 너무 복잡해진다면 protected 데이터 멤버를 활용하는 것이 좋음


### 상속 막기

- 클래스의 추가적인 상속을 막고 싶은 경우
- `final` 한정자 사용
- final이 붙은 클래스는 상속을 할 수 없음
  ```c++
  class First final
  {
    ...
  }
  ```
- final 한정자는 클래스 계층 구조의 어떤 위치에나 붙일 수 있음
  ```c++
  class First
  {
    ...
  }
  class Second final : public First // 중간에 있는 파생 클래스도 상속이 불가능하도록 만들 수 있음
  {
    ...
  }
  ```

### protected 상속

- 실제로 사용되지 않음

### private 상속

- 일부 어플리케이션에서 사용하지만 많이 사용되지는 않음
- 파생 클래스에서 베이스 클래스의 모든 멤버에 접근할 수 없음
- 상속을 할 때, 별도의 접근 제한자를 지정하지 않으면 기본적으로 private 상속이 됨

## ②연관

- 사람 클래스(Person)와 주소 클래스(Address)는 서로 is-a 관계가 아님
  - 사람은 주소가 아니고, 주소도 사람이 아님
  - 따라서 이는 상속 관계가 아님 
- 다중성(multiplicity)
  - 연관과 관련된 객체의 수
  - 다중성의 종류(연관 다이어그램에서의 다중성)
    |표현|설명|
    |--|--|
    |n|n개의 객체|
    |*|0개 이상의 객체|
    |0...1|0~1 개의 객체|
    |n...m|n~m 범위의 객체|
    |n, m|n개 또는 m개의 객체|

### 1)소유

- has-a 관계로 표현하는 객체의 소유와 관련된 특별한 종류의 연관
- 소유 관계에서는 한 객체가 소유자이고, 다른 객체는 소유 대상임
- 소유 대상은 하나 이상일 수 있음

### 2)구성(composition)

- 컨테이너의 존재에 따라서 내부에 있는 내용물의 존재가 달라지는 특별한 종류의 연관
  - 예시 : 어떤 사람(Employee 클래스)과 그 사람의 이름(Name 클래스)
    - 이름은 그 사람이 존재하지 않으면 아무 의미가 없음

## ③의존(= 종속)

- 의존(dependency) 관계는 상속과 연관 관계보다 약한 관게
  - `사용(use-a)관계`라고도 표현
- 클래스 A가 클래스 B를 내부적으로 사용한다면, 클래스 A가 클래스 B를 의존하는 것
- 클래스 B가 없으면 클래스 A가 정상적으로 작동하지 못하는 것을 **의존 관계**라고 부름
  - 클래스 A의 멤버 함수에서 `매개변수`로 클래스 B 자료형을 사용하는 경우
  - 클래스 A의 멤버함수에서 `리턴 값`으로 클래스 B 자료형을 사용하는 경우
  - 클래스 A의 멤버함수에서 `지역변수`로 클래스 B 자료형을 사용하는 경우
- 예시
  - 판매된 제품 목록에 대한 송장을 생성한다고 가정
  - Invoice라는 클래스와 Product 클래스
    - Invoice 클래스는 Product 클래스의 객체를 매개변수로 받는 `add 멤버 함수`가 있음