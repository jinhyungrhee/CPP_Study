# 함수

## 함수란?
- 함수는 어떤 작업을 하기 위해 설계된 엔티티
- `함수 헤더`와 `중괄호`로 감싸진 문장들로 구성

## 함수의 장점

- **분할처리**
  - 복잡하고 어려운 일을 한 번에 하는 것보다 작은 일을 여러 번 하는 것이 더 쉬움

- **오류 확인(디버그)**
  - 오류를 찾는 일은 프로그래밍에서 가장 힘든 작업 중 하나
  - 프로그램을 작은 함수로 나누고 각각의 함수들을 모두 디버깅한 뒤에 다시 하나의 프로그램으로 조립하면
    - 오류 검사가 더 쉬워지며 발견한 오류도 더 쉽게 해결 가능!

- **재사용**
  - 작은 작업들은 더 다양한 곳에 활용할 수 있음
  - 작은 작업들을 분리해서 함수로 만들면, 다양한 프로그램에서 활용하여 쉽게 큰 프로그램을 만들 수 있음

- **함수 라이브러리**
  - 잘 쓰여진 함수들이 보관되어 있는 곳(파일 등)을 의미
  - 운영체제 또는 컴퓨터 하드웨어와의 상호작용과 관련된 작업들은 함수 라이브러리로 미리 작성되어 있어 쉽게 활용 가능

### 함수의 기본 사용법

- `함수 정의`, `함수 선언`, `함수 호출`이라는 엔티티가 필요
- **함수 정의(function definition)**
  - 함수를 만드는 것을 의미
    ```c
    리턴_자료형 함수_이름(매개변수_리스트)
    {
      본문
    }

    // 두 개의 정수 값을 받아서 큰 값을 리턴하는 함수
    int larger(int first, int second) // 헤더
    {
      int temp;
      if(first > second)
      {
        temp = first;
      }
      else
      {
        temp = second;
      }
      return temp;
    }
    ```
- **함수 선언(function declaration)**
  - 함수 프로토타입(function prototype)이라고도 함
    - 함수가 메인 함수 뒤쪽에 작성된 경우, 프로그램에게 해당 함수가 존재한다고 알려주는 것!
  - 함수의 헤더와 세미콜론만 조합된 구문
  - 함수 헤더에서 매개변수의 이름은 입력하지 않아도 됨
    ```c
    int larger(int first, int second); // 매개 변수(parameter)에 이름을 넣은 경우 -> 바람직!

    int larger(int, int);             // 매개 변수(parameter)에 이름을 넣지 않은 경우
    ```

- **함수 호출(function call)**

  - 함수의 내용을 실행하기 위해서 함수를 호출하는 것
  - 후위 증가와 후위 감소가 속했던 `후위 표현식 그룹`에 속함!
    |그룸|이름|연산자|표현식|우선순위|결합방향|
    |--|--|--|--|--|--|
    |후위 표현식|함수 호출|(...)|이름(표현식, ...)|18|→|
  - 함수 호출은 부가 작용(side effect)와 리턴값을 가질 수 있음!
    ```c
    int main()
    {
      cout << larger(3, 13); // 함수를 호출하는 쪽에서 전달되는 값을 인수(argument)라고 함!
      cout << larger(10, 12);
      cout << larger(2, 12);
      return 0;
    }
    ```

### argument와 parameter

- `parameter`는 함수 정의에 있는 변수 선언을 뜻함
- `argument`는 함수를 호출할 때 매개변수를 초기화하는 값
- `parameter`는 변수를 할당할 때 왼쪽에 위치하는 변수라고 할 수 있으며, `argument`는 오른쪽에 위치하는 값이라고 할 수 있음!
  ```c
  int larger(int first, int second);

  int main()
  {
    cout << larger(3, 13);

    return 0;
  }

  // 이 경우, int first = 3; int second = 13; 으로 값이 초기화되는 것임!
  // parameter는 왼쪽에 있는 변수가 되고, argument는 오른쪽에 있는 값이 됨!
  ```

### 함수의 종류

- `라이브러리 함수`와 `사용자 정의 함수`로 구분
- 라이브러리 함수
  - C++ 라이브러리에는 미리 정의된 함수가 존재
  - 라이브러리 내부의 함수를 사용하려면 라이브러리를 읽어 들여야 함
  - 종류
    - 수학 함수
      - 수학과 관련된 라이브러리 함수
      - 이러한 함수들은 `<cmath> 헤더`에 포함되어 있음
      - cmath의 c는 이 라이브러리가 C언어로부터 이어져왔다는 것을 의미함
      - 숫자 함수
        - 숫자 계산에 사용되는 함수
        - 일반적으로 하나 이상의 숫자를 매개변수로 받고 숫자를 리턴
          |함수 선언|설명|
          |--|--|
          |type abs(type x);|x의 절대값을 리턴|
          |type ceil(type x);|x보다 작거나 같은 가장 큰 정수를 리턴|
          |type floor(type x);|x보다 크거나 같은 가장 작은 정수를 리턴|
          |type log(type x);|x의 자연 로그(밑이 e)를 리턴|
          |type log10(type x);|x의 상용 로그(밑이 10)를 리턴|
          |type exp(type x);|e의 x승을 리턴|
          |type pow(type x, type y);|x의 y승을 리턴|
          |type sqrt(type x);|x의 루트(x의 1/2승)를 리턴|
      - 삼각 함수
        - 이 함수들은 `<cmath> 헤더`에 포함
          |함수 선언|설명|매개변수 단위|리턴값의 범위|
            |--|--|--|--|
            |type cos(type x);|코사인을 리턴|라디안|-1 ~ +1|
            |type sin(type x);|사인을 리턴|라디안|-1 ~ +1|
            |type tan(type x);|탄젠트를 리턴|라디안|부동소수점|
            |type acos(type x);|역코사인을 리턴|-1 ~ +1|0 ~ π|
            |type asin(type x);|역사인을 리턴|-1 ~ +1|0 ~ π|
            |type atan(type x);|역탄젠트를 리턴|부동소수점|-π/2 ~ +π/2|
      - 문자 구분 함수
        - 문자를 처리할 때 활용하는 함수
        - 모든 문자 처리 함수는 `<cctype> 라이브러리`(C Character Type)에 있음
          |함수 선언|역할|
          |--|--|
          |int isalnum(int x);|매개변수가 알파벳 또는 숫자인지 확인|
          |int isalpha(int x);|매개변수가 알파벳인지 확인|
          |int iscntrl(int x);|매개변수가 control 문자인지 확인|
      - 시간 함수
        - **time(0) 함수**는 `<ctime> 헤더 파일`에 정의되어 있음
        - 유닉스 타임(Unix Time: 1970년 1월 1일 0시를 기준으로 지난 초 단위의 시간)을 리턴함
      - 랜덤 함수
        - rand(), srand()는 `<cstdlib> 헤더 파일`에 정의되어 있음
        - 범위 확대/축소  
          `temp = rand() % (b-a+1)`
        - 범위 이동  
          `result = temp + a`

- 사용자 정의 함수
  - 각자 필요한 함수가 모두 라이브러리에 정의되어 있지는 않기 때문에 필요한 함수는 따로 정의해서 사용해야 함
  - 4가지 사용 패턴
    - **매개변수가 없는 void 함수**
      - 가장 기본적인 패턴
      - 함수 내부에서 부가 작용을 일으키기 위해서만 사용
      - 부가 작용을 일으키지 않는다면 함수에 의미가 없음
        - 모니터에 출력되는 것도 일종의 부가 작용임!
      - 값을 리턴하지 않으므로, 값이 필요한 위치에 활용할 수 없음
        ```c
        void 이름()
        {
          ...
          return;
        }
        ```
    - **매개변수가 있는 void 함수**
      - 매개변수(parameter)로 값(argument)을 전달해서 활용하는 함수
      - 이러한 함수는 부가작용을 일으키지만, 리턴값을 전달하지는 않음
      - 함수가 부가작용을 일으키고, 이 부가작용에 추가적인 정보가 필요한 경우에 사용하는 패턴
      - 일반적으로 매개변수가 있는 void 함수는 '입력-처리-출력'이라는 설계에서 `출력` 부분에 많이 사용
        ```c
        void 이름(자료형 parameter, ...)
        {
          ...
          return;
        }
        ```
    - 매개변수가 없지만 리턴값이 있는 함수
      - 리턴값을 목적으로 사용하는 함수
      - 일반적으로 함수 내부에서 입력을 받고 이를 리턴
      - '입력-처리-출력'이라는 설계에서 `입력` 부분에 많이 사용
        ```c
        자료형 이름()
        {
          ...
          return value;
        }
        ```
    - 매개변수와 리턴값이 있는 함수
      ```c
      자료형 이름(자료형 parameter, ...)
      {
        ...
        return value;
      }
      ```

### 자료교환

- 자료 전달
  - 호출되는 함수에 매개변수가 존재한다면, 함수 호출 때의 값(argument)이 호출되는 함수의 매개변수(parameter)로 전달
  - `값으로 전달(pass-by-value)`, `참조로 전달(pass-by-reference)`, `포인터로 전달(pass-by-pointer)`의 3가지 매커니즘으로 구분
  - **값으로 전달(pass-by-value)**
    - 인수(argument)의 **값이 복사**되어서 매개변수(parameter)에 할당
    - 원래의 값은 변경되지 않음
    - 호출되는 함수 쪽에서 인수를 변경하지 않게 만들고 싶을 때 사용
    - 값으로 전달 메커니즘에서 호출되는 함수(= 받는 쪽)는 인수의 값을 읽기만 할 수 있음!
      - 이를 '읽기 전용 접근(read-only access)'라고 함!
  - **참조로 전달(pass-by-reference)**
    - 호출되는 함수에서는 변수를 위한 메모리 공간이 추가로 할당되지 않음
    - 매개변수로 전달된 변수의 메모리 공간을 그대로 사용
      - 실질적인 메모리 공간에 있는 값을 바로 처리해주는 것
      - 원본의 데이터 값이 바뀔 수 있음
    - 예시
      ```c
      int main()
      {
        int x = 10;
        fun(x);
        ...
      }

      void fun(int& y)
      {
        ...
      }
      // 변수 y를 위한 메모리 공간이 추가로 할당되지 않고
      // 매개변수로 전달된 변수 x의 메모리 공간을 사용!
      ```
  - **포인터로 전달(pass-by-pointer)**
    - 인수로 메모리 주소를 매개변수에 전달하는 것
    - 주소를 전달하므로 매개변수를 사용해서 인수의 메모리 위치에 접근할 수 있음
  - **장점과 단점**
    - `값으로 전달 메커니즘(pass-by-value)`은 매우 간단하고 호출되는 함수 쪽에서 인수를 조작하지 않게 차단함. 이 방법은 인수의 값을 복사해서 매개변수로 전달하므로, 전달해야 하는 값의 크기가 크면(또는 배열의 경우) 복사하는 작업이 무거워질 수 있음. 따라서 객체지향 프로그래밍에서는 객체의 크기가 클 때 값으로 전달 매커니즘을 사용하지 않음.
    - `참조로 전달 메커니즘(pass-by-reference)`은 호출되는 함수 쪽에서 매개변수를 변경해서, 호출한 함수 쪽의 원본(argument)을 변경할 수 있음. 스왑(swap) 등을 구현할 때 가장 좋은 선택지임. 이 메커니즘은 복사가 필요하지 않다는 장점이 있음.
    - `포인터 전달 메커니즘(pass-by-pointer)`은 참조로 전달 메커니즘과 동일한 장점을 가짐.
      - 일반적으로 C++에서는 많이 사용하지 않지만, 전달해야 하는 자료가 포인터의 특성(c언어 문자열, 배열 등)을 가지고 있을 경우에는 '포인터로 전달 메커니즘'을 사용!

- 자료 리턴
  - 리턴 값의 종류에 따라 `값으로 리턴(return-by-value)`, `참조로 리턴(return-by-reference)`, `포인터로 리턴(return-by-pointer)`로 구분
  - **값으로 리턴(return-by-value)**
    - 가장 일반적으로 사용되는 메커니즘
    - 호출되는 함수 쪽에서 어떤 표현식을 생성하고 이를 리턴
    - 함수를 호출하면 값이 리턴되므로, 값이 필요한 위치에 함수를 활용
  - **참조로 리턴(return-by-reference)**
    - 객체지향 프로그래밍 메커니즘에서는 크기가 큰 객체를 리턴해야 하는 경우가 있음
    - 이때 복사로 인해서 발생하는 비용을 줄이려면, 참조로 리턴하는 것이 좋음
    - 다만 호출되는 함수에서 객체를 생성하면, 함수가 종료된 이후에 객체가 사라지며 참조로 리턴할 때는 여러 주의사항을 지켜야 함!
  - **포인터로 리턴(return-by-pointer)**
    - 참조로 리턴 메커니즘과 효과가 같지만, 거의 사용하지 않음(위험!)

### 기본 매개변수

- 호출할 때마다 특정 매개변수가 동일하게 사용되는 경우, '기본 매개변수(default parameter)'를 사용해서 변수에 기본값(default value)을 지정할 수 있음
- 만약 일부 매개변수만 기본 매개변수를 적용하렴녀 오른쪽에 위치하는 매개변수들에만 적용할 수 있음
- 예시
  ```c
  // 정의
  double calcEarnings(double rate, double hours = 40.0);

  // 호출 시
  calcEarnings(payRate); // 이 경우 hours는 40.0임
  calcEarnings(payRate, hourWorked);
  ```

### 함수 오버로딩

- 이름이 같은 함수를 2개 정의할 수 있을까?
  - **매개변수(매개변수의 자료형, 개수, 순서)가 다르다면 가능**
- 이처럼 같은 이름을 사용하는 함수를 정의하는 것을 `함수 오버로딩(function overloading)`이라고 함!
- 프로그램이 같은 이름의 함수를 허용할 때, 함수들을 구분하기 위해 사용하는 기준을 `함수 시그니처(function signature)`라고 부름!
  - 함수 시그니처는 매개변수들의 자료형과 조합임
- 이름이 같은 함수라도 함수 시그니처가 다르다면, 호출 시점에 컴파일러가 자신이 어떤 함수를 호출해야 하는지 구분할 수 있음
- 다만 함수 호출 시점에는 리턴값을 어떤 자료형으로 활용할지 컴파일러가 구분할 수 없으므로, '리턴 자료형'은 함수 시그니처에 포함되지 않음
- 예시
  - 두 int 자료형과 double 자료형의 최대값을 찾기 위해 다른 함수를 정의하는 예시
    ```c
    int max(int a, int b)
    {
      ...
    }
    double max(double a, double b)
    {
      ...
    }
    // 두 함수는 이름은 같지만 매개변수 타입이 다르므로 컴파일러가 구분 가능!
    ```
  - 함수 시그니처가 같은 경우 -> 오버로딩 불가
    ```c
    int get()
    {
      ...
    }
    double get()
    {
      ...
    }
    // 리턴값이 다른 것은 상관이 없음. 매개변수 타입, 개수, 순서가 달라야 함!
    ```

### 함수의 사용범위와 유지 기간(스코프, 수명)

- 스코프
  - 어떤 엔티티(상수, 변수, 객체, 함수 등)를 사용할 수 있는 범위를 나타냄
  - **지역 스코프(local scope)**
    - 지역 스코프를 가진 엔티티는 선언된 위치부터 블록이 끝나는 부분(닫는 중괄호) 내부에서 사용할 수 있음
      ```c
      // 매개변수의 scope
      void fun(int num)
      {
        ...
      } // num의 scope

      // 카운터의 scope
      for(int i; i < 5; i++)
      {
        ...
      } // i의 scope

      // 지역변수의 scope
      int main()
      {
        int sum;
        ...
      } // sum의 scope
      ```
    - 스코프 겹침
      - 블록 내부에 같은 이름을 가진 엔티티 2개가 올 수는 없음
      - 이러한 경우 컴파일 오류 발생
        ```c
        int calculate(int num)
        {
          int num = 0;
          ...
        } // 매개변수 num의 스코프와 지역변수 num의 스코프 -> 단일 블록의 스코프 겹침
        ```
    - 중첩 블록의 스코프
      ```c
      int main()
      {
        int sum = 0;
        
        for(int i = 0; i < 10; i++)
        {
          sum += i;
        } // i의 scope

        cout << sum << endl;
      } // sum의 scope
      ```
  - **전역 스코프(gloabl scope)**
    ```c
    void print();
    int sum = 0; // 전역 엔티티
    int main()
    {
      sum++;
      print();
    }
    void print()
    {
      cout << sum << endl;
    }
    // sum의 scope
    ```
  - 함수 이름의 스코프
    - 함수는 이름을 가진 엔티티이며, 이 이름에도 스코프가 있음
    - 함수를 선언한 시점부터 프로그램의 마지막 부분까지를 스코프로 가짐!
    - 함수 매개변수도 이름이 있는 엔티티이므로 스코프를 가지며, 함수 헤더부터 함수 블록까지를 스코프로 가짐
      - 프로토타입이 있는 경우
        ```c
        void print(int, int); // print의 scope 시작
        int main()
        {
          ...
          print(x,y);
          ...
        }
        void print(int xx, int yy) // 매개변수의 scope 시작
        {
          ...
        } // print의 scope 끝, 매개변수의 scope 끝
        ```
      - 프로토타입이 없는 경우
        ```c
        void print(int xx, int yy) // print의 scope 시작, 매개변수의 scope 시작
        {
          ...
        } // 매개변수의 scope 끝
        int main()
        {
          ...
          print(x,y);
          ...
        } // print의 scope 끝
        ```

- 수명
  - **자동 지역 변수(automatic local variable)**
    - 함수가 호출될 때 생성되고 함수가 종료될 때 소멸
    - 기본적으로 함수 내부의 모든 지역변수들은 자동 지역 변수
  - **정적 지역 변수(static local variable)**
    - `static` 변경자를 앞에 붙여서 생성
    - 프로그램이 종료되기 전까지 유지
    - 한 번만 초기화되며 프로그램이 살아있는 동안(실행되고 있는 동안), 프로그램은 메모리 위의 변수를 추적
    - 따라서 함수를 여러 번 호출하면, 모든 함수들이 같은 변수를 공유

- 초기화
  - `자동 지역 변수`는 초기화하지 않으면, 메모리에 남아있는 쓰레기값(garbage value)을 가짐
  - `전역 변수`와 `정적(static) 지역 변수`는 초기화하지 않으면, 기본값(정수는 0, 부동소수점은 0.0, 불은 false)으로 초기화
    - 전역 변수와 정적 지역 변수는 같은 값으로 초기화됨! 