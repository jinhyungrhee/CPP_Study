# 포인터

- 포인터 자료형은 메모리 위치의 주소를 나타내는 복합 자료형
- 포인터 변수는 포인터 자료형를 갖는 변수

## 주소

- 메모리 주소
  - 컴퓨터 메모리는 바이트의 연속
    - 메모리에서 접근 가능한 가장 작은 단위가 바이트
    - 1KB 메모리(RAM)는 2^10 = 1024 바이트
  - 각각의 바이트에는 주소가 있으며 이러한 주소는 16진수 형식으로 표현하는 것이 일반적
    - 1KB 메모리를 갖는 컴퓨터의 바이트는 0x000부터 0x3ff까지 나타낼 수 있음

- 변수의 주소
  - 프로그램에서 사용되는 다양한 자료형의 변수들은 1바이트 이상의 메모리를 가짐
    - 불과 문자는 1바이트 차지
    - 정수와 부동 소수점은 4바이트 또는 그 이상을 차지
  - sizeof 연산자를 통해 몇 바이트를 차지하고 있는지 확인 가능
  - 변수의 주소는 `첫 번째 바이트의 주소`를 의미!
    - 주소와 포인터를 기반으로 어떤 작업을 할 때 반드시 기억해야 하는 중요한 내용
  - 변수의 주소를 추출하려면 `주소 연산자(&)` 사용

- `추출 연산자(<<)`는 포인터를 출력할 수 있게 오버로드 되어 있음
  - `cou << &score` 같은 형태로 변수의 주소 출력 가능!
- 주소는 16진법으로 출력
- 크기와 주소는 시스템에 따라 다름

## 포인터 자료형과 포인터 변수

- 포인터 자료형
  - **리터럴의 값이 주소**인 복합 자료형
    - 주소를 값으로 저장하고 있는 자료형
  - char 포인터(=char 변수의 주소), int 포인터(=int 변수의 주소), double 포인터(= double 변수의 주소) 등
  - 자료형 뒤에 별 기호(*)를 붙여서 생성
    ```c++
    bool*
    int*
    double*
    Circle*
    ```

- 포인터 변수
  - 포인터 자료형의 값을 포인터 변수에 저장할 수 있음
  - 포인터 자료형의 크기는 무조건 `4바이트`!
  - 포인터 변수는 0x00000000부터 0xFFFFFFFF까지의 주소 저장 가능

- 선언
  - 포인터 변수를 선언하려면 어떤 자료형의 포인터를 선언할 것인지 지정해야 함
    ```c++
    bool* pFlag;
    int* pScore;
    double* pAverage;
    ```
    - 이후에 여기에 변수들의 주소를 바인드(연결)함!

- 초기화
  - 리터럴 주소로는 초기화하지 않음
  - **기존에 있는 변수의 주소**로 초기화
    - 따라서 **주소 연산자(&)와 변수를 조합한 형태**를 사용!
      ```c++
      bool* pFlag = &flag;
      int* pScore = &score;
      double* pAverage = &average;
      ```
  
- **간접 참조**
  - 포인터 변수에 저장된 주소를 활용해서 포인트된 변수의 값에 접근 가능
  - 간접 참조 연산자(indirection operation) : `*`
    ```c++
    *pFlag;
    *pScore;
    *pAverage; // '해당 주소가 가리키고 있는 곳의 내용'을 의미
    ```

- 연산자 정리
  |그룹|이름|연산자|표현식|우선순위|결합방향|
  |--|--|--|--|--|--|
  |단항|주소|&|&lvalue|17|←|
  |단항|간접 참조|*|\*pointer|17|←|
  - `&변수`를 실행하면 항상 `주소`가 나옴!
  - `*주소`를 실행하면 항상 `값`이 나옴!

- `*`와 `&` 정리
  |기호|자료형 정의|단항 연산자|이항 연산자|
  |--|--|--|--|
  |&|자료형&(참조변수)|&변수(변수의 주소)|x&y(비트 AND 연산)|
  |*|자료형\*(포인터변수)|\*변수(주소에 담긴 값/내용)|x\*y(곱셈 연산)|

- const 한정자 사용
  - 3가지 목적
    - 데이터 변경 관련
      - ① 직접 참조 + 값 변경 불가
        ```c++
        const int score = 92;
        ```
      - ② 간접 참조 + 값 변경 불가 (= **주소는 변경 가능**)
        ```c++
        const int* pScore = &score;
        ```
    - 데이터 변수와 포인터 변수 사이의 관계 변경 관련
      - ③ 주소 변경 불가 (= **값은 변경 가능**)
        ```c++
        int* const pScore = &score;
        ```

  - 데이터 변경 제어 조합
    |경우|데이터 변수|포인터 변수|
    |--|--|--|
    |1|int name = value;|int* pName = &name;|
    |2(사용X)|const int name = value;|int* pName = &name;|
    |3|int name = value;|const int* pName = &name;|
    |4|const int name = value;|const int* pName = &name;|
    - 경우1 : 어떠한 제한 X
      ```c++
      int score = 92;
      int* pScore = &score;
      score = 80; // 문제X
      *pScore = 70; // (간접참조) 문제X
      ```
    - 경우2 : 포인터 변수는 상수의 주소는 저장할 수 없음
      ```c++
      const int score = 92;
      int* pScore = &score; // 컴파일 에러
      ```
    - 경우3 : 포인터 변수로는 값을 변경하지 못하도록 함
      ```c++
      int score = 92;
      const int* pScore = &score; // 간접 참조(*)를 통한 변경 제한
      score = 80; // 가능
      *pScore = 90; // 불가능 (컴파일 에러)
      ```
    - 경우4 : 데이터 변수(직접)와 포인터 변수(간접)로 값을 모두 변경할 수 없음(거의 사용X)
      ```c++
      const int score = 92; // 직접 변경 제한
      const int* pScore = &score; // 간접 변경 제한
      score = 80; // 컴파일 에러
      *pScore = 90; // 컴파일 에러
      ```

  - 포인터 변경하기
    |포인터 변수 선언|포인터 관계 변경|
    |--|--|
    |자료형* 포인터_변수_이름 = &데이터_변수_이름|관계 변경 가능|
    |자료형* **const** 포인터_변수_이름 = &데이터_변수_이름|관계 변경 **불가**|

- 포인터의 포인터
  - 포인터 변수도 메모리 위에 위치를 잡고 있음
  - 포인터의 포인터는 * 기호를 2회 사용함
    ```c++
    int score = 92;
    const int* pScore = &score;
    int** ppScore = &pScore;
    ```

- 특수한 포인터
  - 널 포인터
    - 아무 것도 가리키지 않는 포인터
    - c++에서는 리터럴 0을 사용하여 널 포인터를 정의함
      ```c++
      int* p1 = 0; // 가리키는 대상이 없는 null pointer
      double* p2 = 0;
      ```
      - 프로그래머들은 이처럼 포인터에 0을 할당해서 포인터를 사용할 수 없음
        - 포인터가 가리키는 데이터에 접근하려고 할 때 오류가 발생해서 프로그램이 중단됨 
      - 포인터는 널 포인터일 때 false로 변환되고, 이외의 경우에는 true로 변환됨
        ```c++
        int x = 7;
        int*p = &x;
        if (p) {...} // true
        p = 0;        // null pointer
        if (p) {...} // false
        ```
  - 범용 포인터(generic pointer)
    - void 포인터
    - 모든 자료형의 객체를 가리킬 수 있음
      ```c++
      void* p; // void 포인터 선언
      int x = 10;
      p = &x;  // int type 가리키는 것 가능
      double y = 23.4;
      p = &y;  // double type 가리키는 것 가능
      ```

## 배열과 포인터

- 포인터 산술 연산
  - 포인터 연산을 사용하면 결과로 포인터(=주소 정보)가 나옴
  - 배열을 선언하고 배열의 **특정 메모리 위치에 접근**할 때 포인터 연산 사용
  - **덧셈과 뺄셈 연산자**
    ```c++
    int* ptr = &arr[2]; // 2번 인덱스

    int* ptr1 = ptr + 2; // 4번 인덱스

    int* ptr2 = ptr - 2; // 0번 인덱스
    ```
  - **증가와 감소 연산자**
    - 배열의 이름은 상수이므로, 배열의 이름에는 적용할 수 없음
      ```c++
      int* ptr = &arr[2]; // 2번 인덱스

      ptr++; // 3번 인덱스

      ptr--; // 2번 인덱스
      ```
  - **복합 덧셈/뺄셈 연산자**
      ```c++
      int* ptr = &arr[2]; // 2번 인덱스

      ptr += 2; // 4번 인덱스

      ptr -= 3; // 1번 인덱스
      ```
  - **포인터 뺄셈**
    - 포인터에서 포인터를 빼면 결과로 정수가 나옴
    - 요소의 인덱스에서 요소의 인덱스를 빼는 것과 같은 처리
    - 포인터에 포인터를 더하는 연산은 제공되지 않음

  - 주의
    - 연산으로 배열의 범위를 벗어나는 위치에 접근할 경우, 해당 메모리 위치에 문제를 일으킬 수 있음

- 함수에 배열을 포인터로 전달 가능
  ```c++
  int getSum(const array[], int size);
  int getSum(const int* p, int size);
  // 동일한 표현임!
  ```
- **2차원 배열과 포인터**
  - 2차원 배열은 배열의 배열
    ```c++
    int* matrix[3][4] = { {10, 11, 12, 13}, {20, 21, 22, 23}, {30, 31, 32, 33}};
    ```
  - 2차원 배열을 '정수에 대한 포인터의 포인터'라고 생각하는 경우도 있지만, 실제로 2차원 배열은 int(matrix*)[4]라는 '4개의 정수를 갖는 배열에 대한 포인터'임!